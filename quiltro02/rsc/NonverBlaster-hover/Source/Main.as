/*NonverBlasterSimple VideoPlayer by Nonverblahttp://www.nonverbla.de*/package {	import de.popforge.events.*;	import nonverblaster.*;	import gs.TweenLite;	import gs.easing.*	import flash.display.*;	import flash.text.*;	import flash.geom.*;	import flash.events.*;	import flash.media.*;	import flash.net.*;	import flash.external.*;	import flash.system.Security;	import flash.utils.*;	import flash.ui.*;		public class Main extends MovieClip {		// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// Constants 		//		// Timer speed in Milliseconds		private const INTERVAL_MS:uint = 1;		private const FADEOUT_MS:uint = 2500;		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// Other Variables 		//		// For testing in Flash:		// Should the Player behave like running in fullScreen or not?		private var isFullScreen:Boolean = false;		//		public var isPlaying:Boolean = false;		public var isSeeking:Boolean = false;		//		// Variables for the Volume Control		private var volumeTransform:SoundTransform = new SoundTransform();		private var oldVolume:Number;		//		private var stageRatio:Number;		private var targetRatio:Number;		//		private var tweenSpeed:Number = .5;		//		// The »i« for the »for(){} loops«		private var i:int;		//		// All used classes		private var playlist:XML; 		private var uldr:URLLoader;		private var videosXML:XMLList;		public var isComplete:Boolean = false;		private var hideTimer:Timer;		private var loopTimer:Timer;		private var uiElements:Array = new Array();		// Margins		public var gap:uint = 5;		private var margin:uint = 20;		private var controlHeight:uint = 20;		//		public var started:Boolean;		private var theVideo:TheVideo;		private var teaser:Teaser= new Teaser();				public var mediaObject:MovieClip;				public var control:Control;		private var customContextMenu:CustomContextMenu;				//		// ==================================================================================================================================		// Constructor ______________________________________________________________________________________________________________________		//		public function Main() {			initialize();			visible = false;			textFeld.visible = false;			//bufferWheel.fadeIn();		}		private function initialize(){						flash.system.Security.allowDomain("*");			//			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.align = StageAlign.TOP_LEFT;			stage.quality = StageQuality.HIGH;			//						theVideo = new TheVideo(this);			theVideo.stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler, false, 0, true);						control = new Control();			this.addChild(control);			control.init(this, gap, margin, tweenSpeed);			control.y = -40;						scaleBt.init(this);						uiElements.push(control, scaleBt);						// Timer for hiding the control			hideTimer = new Timer(2500, 1);			hideTimer.addEventListener(TimerEvent.TIMER, hideTimerHandler);			//			//			customContextMenu = new CustomContextMenu(this);			this.addChild(customContextMenu);			customContextMenu.init();						loopTimer = new Timer(20,0);			loopTimer.addEventListener(TimerEvent.TIMER, loopIt, false, 0, true);			loopTimer.start();						setVariables();			restartBt.setTint();			control.setTint();			scaleBt.setTint();			bufferWheel.setTint();						init();						setVolume(Glo.bal.defaultVolume);					}		//		// Parsing of the FlashVars		private function setVariables():void {			Glo.bal.videoURL = "../nice-flowers.mov";			Glo.bal.teaserURL = "../nice-flowers.jpg";			//Glo.bal.videoURL = "http://www.freisprung.com/movies/clouds.flv";			Glo.bal.autoPlay = "true";			Glo.bal.allowSmoothing = "true";			Glo.bal.buffer = 6;			Glo.bal.showTimecode = "true";			Glo.bal.loop = "false";			Glo.bal.controlColour = 0xffffff;			Glo.bal.showScalingButton = "true";			Glo.bal.scaling = true;			Glo.bal.defaultVolume = 1;						var flashVars:Object = root.loaderInfo.parameters;						// set all flashVars toLowerCase(), to avoid faults with titleCaseStuff ;)						var keyStr:String;		    var valueStr:String;			for (keyStr in flashVars) {				valueStr = String(flashVars[keyStr]);				flashVars[keyStr.toLowerCase()] = valueStr.toLowerCase();				//trace(keyStr.toLowerCase() + ": " + valueStr.toLowerCase());			} 						flashVars.videoURL != undefined ? Glo.bal.videoURL = flashVars.videourl : 0;			flashVars.teaserURL != undefined ? Glo.bal.teaserURL = flashVars.teaserurl : 0;			flashVars.autoPlay != undefined ? Glo.bal.autoPlay = flashVars.autoplay : 0;			flashVars.allowSmoothing != undefined ? Glo.bal.allowSmoothing = flashVars.allowsmoothing : 0;			flashVars.buffer != undefined ? Glo.bal.buffer = Number(flashVars.buffer) : 0;			flashVars.showTimecode != undefined ? Glo.bal.showTimecode = flashVars.showtimecode : 0;			flashVars.loop != undefined ? Glo.bal.loop = flashVars.loop : 0;			flashVars.controlColour != undefined ? Glo.bal.controlColour = flashVars.controlcolour : 0;			flashVars.showScalingButton != undefined ? Glo.bal.showScalingButton = flashVars.showscalingbutton : 0;			flashVars.defaultVolume != undefined ? Glo.bal.defaultVolume = (flashVars.defaultvolume / 100) : 0;			if(flashVars.scaleiffullscreen != undefined){				Glo.bal.scaling = flashVars.scaleiffullscreen == "true" ? true : false;			}		}		public function setScaling(_scaling){			fitToScreen();		}				private function loopIt(event:TimerEvent){			for(i=0; i<uiElements.length; i++){				try {					uiElements[i].loopIt();				} catch (e:Error){};			}		}		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// The init function		//		public function init():void {			stage.addEventListener(Event.MOUSE_LEAVE, onStageHandler);			stage.addEventListener(MouseEvent.MOUSE_MOVE, onStageHandler);						//			// Keyboard events			stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler, false, 0, true);			stage.addEventListener(Event.FULLSCREEN, fullSreenHandler, false, 0, true);			stage.addEventListener(Event.RESIZE, resizeHandler, false, 0, true);			//			// start the Video			if (Glo.bal.autoPlay == "true") {				hideUI();				playVideo();			} else {				showTeaser();				setDefault();				showRestart();				showUI();			}		}		private function showTeaser(){			container.addChild(teaser);			teaser.init(this);			teaser.loadPic(Glo.bal.teaserURL);			teaser.visible = true;			mediaObject = teaser;		}		private function hideTeaser(){			try {				container.removeChild(teaser);			} catch (e:Error){};		}				////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// Play the Video 		// 		public function playVideo():void {			hideRestart();			if(mediaObject == teaser || mediaObject == null){				bufferWheel.fadeIn();				teaser.visible = false;				setMediaObject(theVideo);				theVideo.init(Glo.bal.buffer, Glo.bal.allowSmoothing, Glo.bal.videoURL);				control.setActive();				theVideo.playVideo();			} else if(mediaObject == theVideo){				theVideo.restartVideo();			}			isPlaying = true;			isComplete = false;			control.setState(isPlaying);			if (started == false){				started = true;				startHideTimer();			}		}		private function setDefault():void {			isPlaying = false;			theVideo.setDefault();			control.setState(isPlaying);		}		private function setEnd():void {			trace("setEnd");			bufferWheel.fadeOut();			if(Glo.bal.loop == "true"){				theVideo.restartVideo();			} else {				isPlaying = false;				isComplete = true;				theVideo.setPause();				showRestart();				control.setState(isPlaying);				stopHideTimer();				hideUI();				showTeaser();				Mouse.show();			}		}		public function togglePlay():void {			theVideo.togglePlay();			isPlaying = !isPlaying;			control.setState(isPlaying);		}				private function setMediaObject(_mediaObject){			container.addChild(_mediaObject);			mediaObject = _mediaObject;			mediaObject.contextMenu = customContextMenu.myContextMenu;					}		//////////////////////////////////////////////////////////////////////		// NetStream Listener		private function netStatusHandler(event:NetStatusEvent):void {			try {				switch (event.info.code) {					case "NetStream.Play.StreamNotFound":						showError("No video was found! \n" + Glo.bal.videoURL);						bufferWheel.fadeOut();						trace("Stream-Image not found!");					break;					case "NetStream.Play.Start" :						visible = true;						bufferWheel.fadeOut();						break;					case "NetStream.Buffer.Full" :												break;					case "NetStream.Buffer.Empty" :						if(isPlaying == true){							bufferWheel.fadeIn();						}						break;					case "NetStream.Play.StreamNotFound" :					case "NetStream.Play.Stop" :					trace(getPlayingProgress());					textFeld.appendText("\n" + getPlayingProgress().toString());						if(isSeeking != true && getPlayingProgress() >= .97){							setEnd();						}						break;				}			} catch (error:TypeError) {}		}				public function getLoadingProgress():Number {			return(theVideo.stream.bytesLoaded / theVideo.stream.bytesTotal);		}		public function getPlayingProgress():Number {			return(theVideo.stream.time / theVideo.meta.duration);		}		public function getElapsedTime():Number {			return(theVideo.stream.time);		}		public function setPlayingProgress(progressBarScale):void {			theVideo.stream.seek(progressBarScale * theVideo.meta.duration);		}		//		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 		// Set the Video Volume		public function setVolume(_volume):void {			volumeTransform.volume = _volume;			theVideo.stream.soundTransform = volumeTransform;		}		public function getVolume() {			return(theVideo.stream.soundTransform.volume);		}		//		// The volume function for the ContextMenu		public function toggleVolume():void {			if (theVideo.stream.soundTransform.volume > 0) {				oldVolume = getVolume();				setVolume(0);			} else {				setVolume(oldVolume);			}			textFeld.text = "toggleVolume";		}		//		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// Adjust wether the video should use smoothing or not		//		public function toggleSmoothing():void {			if(theVideo.videoInstance.smoothing == true){				theVideo.videoInstance.smoothing = false			} else {				theVideo.videoInstance.smoothing = true;			}		}		//		public function toggleSeeking(_isSeeking):void {			isSeeking = _isSeeking;			toggleVolume();		}		//		////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 		// Handler for keyboard events: 		//		private function keyDownHandler(event:KeyboardEvent):void {			//			// If Space is pressed			if (event.keyCode == 27) {				isFullScreen = false;			}			if (event.keyCode == 32) {				togglePlay();			}		}		//		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// POSITION THE ELEMENTS		// 		private function resizeHandler(e:Event){			fitToScreen();		}		public function fitToScreen():void {			fitBufferWheel();			if(mediaObject == teaser){				setExactFit(mediaObject);			} else {				hideTeaser();			}			switch(isFullScreen){				case true:					if(Glo.bal.scaling == false){						if(mediaObject == theVideo){							 if(theVideo.meta.width < stage.stageWidth && theVideo.meta.height < stage.stageHeight){								setCentered(mediaObject); 							 } else {								setExactFit(mediaObject); 							 }						} else {							setCentered(mediaObject);						}					} else {						setExactFit(mediaObject);					}					control.fitToScreen(true, 0, 0, stage.stageWidth, stage.stageHeight);					setButtons(0, 0, stage.stageWidth, stage.stageHeight);										break;				case false:					setExactFit(mediaObject);					control.fitToScreen(false, mediaObject.x, mediaObject.y, mediaObject.width, mediaObject.height);					setButtons(mediaObject.x, mediaObject.y, mediaObject.width, mediaObject.height);					break;			}			back.x = 0;			back.y = 0;			back.width = stage.stageWidth + 10;			back.height = stage.stageHeight + 10;		}		private function setExactFit(target){			stageRatio = stage.stageWidth / stage.stageHeight;			targetRatio = target.width / target.height;			//			if (targetRatio > stageRatio) {				target.width = Math.floor(stage.stageWidth);				target.scaleY = target.scaleX;			} else {				target.height = Math.floor(stage.stageHeight);				target.scaleX = target.scaleY;			}			target.x = Math.floor(stage.stageWidth/2 - target.width/2);			target.y = Math.floor(stage.stageHeight/2 - target.height/2);					}		private function setCentered(target){			target.scaleX = target.scaleY = 1;			target.x = Math.floor(stage.stageWidth/2 - target.width/2);			target.y = Math.floor(stage.stageHeight/2 - target.height/2);		}		private function setButtons(vidX, vidY, vidW, vidH){			restartBt.x = Math.floor(vidX + vidW/2 - restartBt.back.width/2);			restartBt.y = Math.floor(vidY + vidH/2 - restartBt.back.height/2);			var theGap;			if(isFullScreen != true){				theGap = gap;				scaleBt.visible = false;			} else {				theGap = margin;				Glo.bal.showScalingButton == "true" ? scaleBt.visible = true : scaleBt.visible = false;			}			scaleBt.x = stage.stageWidth - scaleBt.frame.width - theGap;			scaleBt.y = theGap;		}		private function fitBufferWheel(){			bufferWheel.x = Math.floor(stage.stageWidth / 2);			bufferWheel.y = Math.floor(stage.stageHeight / 2);		}		//		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// Switch FullScreenMode on and off 		//		public function toggleFullScreen():void {			if (isFullScreen == false) {				stage.displayState = StageDisplayState.FULL_SCREEN;			} else {				stage.displayState = StageDisplayState.NORMAL;			}		}		//		// eventHandler for the display state		private function fullSreenHandler(event:FullScreenEvent):void {			if (stage.displayState == StageDisplayState.FULL_SCREEN) {				isFullScreen = true;			} else {				isFullScreen = false;			}			fitToScreen();		}		//		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// Functions for hiding and showing the restartBtton 		// 		private function showRestart():void {			Mouse.show();			restartBt.visible = true;			TweenLite.to(restartBt, tweenSpeed, {alpha:1, ease:Cubic.easeIn});		}		//		public function hideRestart() {			restartBt.visible = false;		}		//		private function onStageHandler(e:Event){			switch (e.type){				case "mouseMove":				if(mouseX > 0 && mouseX < stage.stageWidth && mouseY > 0 && mouseY < stage.stageHeight){					Glo.bal.mouseOnStage = true;					stage.removeEventListener(MouseEvent.MOUSE_MOVE, onStageHandler);					stage.addEventListener(Event.MOUSE_LEAVE, onStageHandler);					startHideTimer();				} else {					Glo.bal.mouseOnStage = false;				}				break;				case "mouseLeave":				Glo.bal.mouseOnStage = false;				stage.removeEventListener(Event.MOUSE_LEAVE, onStageHandler);				stage.addEventListener(MouseEvent.MOUSE_MOVE, onStageHandler);				if(started == true && isComplete != true){					stopHideTimer();					hideUI();				}				break;			}		}		//		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// The Timer for the fading the controls in and out in fullScreen mode 		//		// The mouseHandler		private function mouseMoveStart(event:MouseEvent) {			startHideTimer();		}		private function mouseUpHandler(event:MouseEvent) {			startHideTimer();		}		//		// Fade the UI in / out		public function showUI(){			if(Glo.bal.mouseOnStage == true){				control.fadeIn();				scaleBt.fadeIn();			}		}		public function hideUI(){			control.fadeOut(isComplete);			scaleBt.fadeOut();		}		//		// start the timer		public function startHideTimer() {			if(started == true && isComplete != true){				showUI();				hideTimer.reset();				hideTimer.start();				Mouse.show();				// 				stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveStart);			}		}		//		// stop the timer		public function stopHideTimer() {			hideTimer.reset();			hideTimer.stop();			try {				stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveStart);				stage.removeEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);			} catch(e:Error){};		}		//		// hideTimer eventHandler		private function hideTimerHandler(event:TimerEvent) {			hideUI();			//			stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveStart, false, 0, true);		}		public function showError($log){			stopHideTimer();			visible = true;			restartBt.visible = false;			control.visible = false;			error.textFeld.autoSize = "center";			error.textFeld.text = "Error: " + $log;			error.textFeld.x = -error.textFeld.width / 2;			error.y = stage.stageHeight/2 - error.height/2;			error.x = stage.stageWidth + error.width/2;			TweenLite.to(error, tweenSpeed, {x:stage.stageWidth / 2, ease:Quint.easeInOut});		}	}}