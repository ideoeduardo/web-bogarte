package nonverblaster {	import flash.display.*;	import flash.utils.*;	import flash.events.*;	import flash.ui.*;		import gs.TweenLite;	import gs.easing.*		import de.popforge.events.*;	public class Control extends MovieClip {		private var hoverElements:Array;		private var buttons:Array;		private var lastPlayingBarScale:Number = 0;		private var playinBarScale:Number = 0;		private var gap:uint;		private var margin:uint;				private var fullyLoaded:Boolean = false;		private var i:uint;				private var isFullScreen = false;				private var fullScreenButActWidth = 7;		private var fullScreenButActHeight = 3;		private var fullScreenButPassWidth = 1;		private var fullScreenButPassHeight = 1;				private var volumeControlOn:Boolean = false;		private var volumeControlPressed:Boolean = false;		private var theVolume:Number = 1;		private var newVolumeValue:Number = theVolume;				private var tweenSpeed:Number;				private var main:MovieClip;				public function Control() {			visible = false;		}		public function init(_main, _gap, _margin, _tweenSpeed) {			this.main = _main;			this.gap = _gap;			this.margin = _margin;			this.tweenSpeed = _tweenSpeed;			y = -20;			//						initButtons();			setInactive();						timeCode.alpha = 0;						progressBar.playingBar.width = 0;			volumeBack.height = 0;		}		public function setTint(){			for (i=0; i<hoverElements.length; i++) {				Colorizer.colorize(hoverElements[i], Glo.bal.controlColour);			}		}		public function loopIt() {			computeVolume();			computeProgress();			adjustTimeCode();		}		private function initButtons() {			//			// all elements that get a special color in an Array			hoverElements = new Array(playPause, progressBar, volumeControl.grf, fullScreenBut.grf, timeCode.minText, timeCode.secText, timeCode.colon);			// Configure the various Button instances. Each Button instance uses 			// the same click handler.			buttons = new Array(playPause.hotArea, progressBar.sliderBar, volumeControl.sliderBar, fullScreenBut.hotArea);			for (i=0; i<buttons.length; i++) {				SimpleMouseEventHandler.register( buttons[i] );			}			addEventListener( SimpleMouseEvent.PRESS, sharedButtonHandler );			addEventListener( SimpleMouseEvent.RELEASE, sharedButtonHandler );			addEventListener( SimpleMouseEvent.RELEASE_OUTSIDE, sharedButtonHandler );			addEventListener( SimpleMouseEvent.ROLL_OVER, sharedButtonHandler );			addEventListener( SimpleMouseEvent.ROLL_OUT, sharedButtonHandler );			addEventListener( SimpleMouseEvent.DRAG_OVER, sharedButtonHandler );			addEventListener( SimpleMouseEvent.DRAG_OUT, sharedButtonHandler );		}		public function setInactive(){			for (i=1; i<buttons.length-1; i++) {				buttons[i].mouseEnabled = false;				SimpleMouseEventHandler.unregister( buttons[i] );			}		}		public function setActive(){			for (i=1; i<buttons.length-1; i++) {				buttons[i].mouseEnabled = true;				SimpleMouseEventHandler.register( buttons[i] );			}		}		//		/////////////////////////////////////////////////////////////////////////////////////////////		// eventHandler for all buttons 		// 		private function sharedButtonHandler(event:SimpleMouseEvent):void {			// what button was triggered?			switch (event.target) {				case playPause.hotArea :					switch (event.type) {						case "onRollOver" :							main.stopHideTimer();							break;						case "onRollOut" :							main.startHideTimer();							break;						case "onPress" :							if(main.started == true && main.isComplete == false){								main.togglePlay();							} else {								main.playVideo();							}							break;						case "onReleaseOutside" :							break;					}					break;									case progressBar.sliderBar :					switch (event.type) {						case "onRollOver" :							main.stopHideTimer();							showTimeCode();							break;						case "onRollOut" :							main.startHideTimer();							hideTimeCode();							break;						case "onPress" :							main.toggleSeeking(true);							break;						case "onRelease" :							main.toggleSeeking(false);							break;						case "onReleaseOutside" :							main.startHideTimer();							hideTimeCode();							main.toggleSeeking(false);							break;					}					break;									case fullScreenBut.hotArea :					var inst = fullScreenBut.grf.fill;					switch (event.type) {						case "onRollOver" :							main.stopHideTimer();							TweenLite.to(inst, tweenSpeed, {width:fullScreenButActWidth, height:fullScreenButActHeight, ease:Cubic.easeOut});							break;						case "onRollOut" :							main.startHideTimer();							TweenLite.to(inst, tweenSpeed, {width:fullScreenButPassWidth, height:fullScreenButPassHeight, ease:Cubic.easeOut});							break;						case "onRelease" :							main.toggleFullScreen();							break;					}					break;									case volumeControl.sliderBar :					switch (event.type) {												case "onRollOver" :							main.stopHideTimer();							volumeControlOn = true;							break;						case "onRollOut" :							main.startHideTimer();							volumeControlOn = false;							break;						case "onPress" :							volumeControlPressed = true;							break;						case "onRelease" :							volumeControlPressed = false;							break;						case "onReleaseOutside" :							main.startHideTimer();							volumeControlPressed = false;							volumeControlOn = false;							volumeControl.grf.prevFrame();							break;					}					break;			}		}		/////////////////////////////////////////////////////////////////////////////////////////////		// PLAYING PROGRESS AND SEARCH		//		private function computeProgress():void {			try {				if(main.getLoadingProgress() == 1 && fullyLoaded != true){					fullyLoaded = true;					main.initRelated();				}				// Adjust the loading bar depending on the loaded percent				if(!isNaN(main.getLoadingProgress())){					progressBar.loadingBar.scaleX += (main.getLoadingProgress() - progressBar.loadingBar.scaleX)/5;					progressBar.sliderBar.width = progressBar.loadingBar.width - 1;				}								if (main.isSeeking == true) {						theSliderRules();				} else {					theProgressRules();				}			} catch (error:Error) {			}		}		//		//		private function adjustTimeCode(){			timeCode.y = Math.floor(back.y - timeCode.back.height);						timeCode.x = Math.floor(progressBar.x + progressBar.playingBar.width * progressBar.scaleX + timeCode.back.width / 2);						var pos = main.getElapsedTime();			var minutes:Number = Math.floor(pos  / 60);			var seconds:Number = Math.floor(pos) % 60;			timeCode.minText.text = ((minutes < 10) ? "0" + minutes : minutes);			timeCode.secText.text = ((seconds < 10) ? "0" + seconds : seconds);		}		private function showTimeCode(){			if(Glo.bal.showTimecode == "true"){				TweenLite.to(timeCode, tweenSpeed, {alpha:1, ease:Cubic.easeOut});			}		}		private function hideTimeCode(){			TweenLite.to(timeCode, tweenSpeed, {alpha:0, ease:Cubic.easeIn});		}				//		// Adjust the playing bar depending on the played percent		function theProgressRules():void {			progressBar.playingBar.scaleX += (main.getPlayingProgress() - progressBar.playingBar.scaleX)/5;			//			// Das BufferRad zeigen bzw verstecken			playinBarScale = progressBar.playingBar.scaleX;			lastPlayingBarScale = playinBarScale;		}		//		// If the slider is dragged:		// Adjust the playing progress depending on the scale of the playingBar		function theSliderRules():void {			if (progressBar.playingBar.width <= progressBar.sliderBar.width) {				//progressBar.playingBar.width += (progressBar.mouseX - progressBar.playingBar.width)/3;				progressBar.playingBar.width = progressBar.mouseX;			}			if (progressBar.playingBar.width > progressBar.sliderBar.width) {				progressBar.playingBar.width = progressBar.sliderBar.width;			}			main.setPlayingProgress(progressBar.playingBar.scaleX);		}		//		/////////////////////////////////////////////////////////////////////////////////////////////		// VOLUME CONTROL 		private function computeVolume():void {			if (volumeControlOn == true) {				volumeControl.sliderBar.height = 115;				volumeControl.grf.nextFrame();				if (volumeControlPressed == true) {					volumeSliderRules();				} else {					volumeValueRules();				}			} else {				volumeControl.grf.prevFrame();				volumeControl.sliderBar.height = 11;				volumeSliderDefault();			}		}		private function volumeSliderRules():void {			newVolumeValue = -volumeControl.mouseY / 70;			if (newVolumeValue > 1.5) {				newVolumeValue = 1.5;			} else if (newVolumeValue < 0) {				newVolumeValue = 0;			}			main.setVolume(newVolumeValue);			moveVolumeBar(newVolumeValue*70);		}		private function volumeValueRules():void {			moveVolumeBar(main.getVolume()*70);			toggleVolumeControl(110);		}		private function volumeSliderDefault():void {			moveVolumeBar(3);			toggleVolumeControl(5);		}		private function moveVolumeBar(targetY):void {			volumeControl.grf.bar4.height += (targetY - volumeControl.grf.bar4.height)/3;			for (i=1; i<=3; i++) {				volumeControl.grf["bar"+i].height += (volumeControl.grf["bar"+(i+1)].height - volumeControl.grf["bar"+i].height - 1)/1.5;				if (volumeControl.grf["bar"+i].height < 0.99) {					volumeControl.grf["bar"+i].height = 0;				}			}		}		private function toggleVolumeControl(targetY):void {			volumeBack.height = volumeControl.grf.volumeFrame.height - (volumeControl.y + 1);			volumeControl.grf.volumeFrame.sides.height += (targetY - volumeControl.grf.volumeFrame.sides.height)/3;			volumeControl.volumeMask.height = volumeControl.grf.volumeFrame.sides.height+2;			volumeControl.grf.volumeFrame.volumeTop.y = -volumeControl.grf.volumeFrame.sides.height-2;		}		public function setState(isPlaying){			if (isPlaying == true) {				playPause.gotoAndStop(1);			} else {				playPause.gotoAndStop(2);			}		}		public function fitToScreen(isFullScreen, vidX, vidY, vidW, vidH){			this.isFullScreen = isFullScreen;			switch (isFullScreen) {				case true:					x = Math.floor(vidX + margin);					y = Math.floor(stage.stageHeight - back.height - margin);					back.width = stage.stageWidth - margin * 2;					//					fullScreenBut.x = Math.floor(back.width - fullScreenBut.grf.width - gap);					volumeControl.x = fullScreenBut.x - fullScreenBut.grf.width - gap;					//					progressBar.x = playPause.x + playPause.grf.width + gap;					progressBar.width = Math.floor(back.width - progressBar.x - fullScreenBut.grf.width - gap*3 - volumeControl.width);					//					fullScreenButActWidth = 1;					fullScreenButActHeight = 1;					fullScreenButPassWidth = 7;					fullScreenButPassHeight = 3;					//					fullScreenBut.grf.fill.width = 7;					fullScreenBut.grf.fill.height = 3;					break;				case false:					x = Math.floor(vidX);					y = Math.floor(vidY + vidH - back.height+1);					back.width = Math.floor(vidW);					//					progressBar.x = playPause.x + playPause.grf.width + gap;					progressBar.width = Math.floor(back.width - progressBar.x - fullScreenBut.grf.width - gap*3 - volumeControl.width);					//					fullScreenBut.x = Math.floor(back.width - fullScreenBut.grf.width - gap);					volumeControl.x = fullScreenBut.x - fullScreenBut.grf.width - gap;					//					fullScreenButActWidth = 7;					fullScreenButActHeight = 3;					fullScreenButPassWidth = 1;					fullScreenButPassHeight = 1;					//					fullScreenBut.grf.fill.width = 1;					fullScreenBut.grf.fill.height = 1;					break;			}			volumeBack.x = volumeControl.x - 4;		}				//		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// Functions for fading the control in and out  		//		// fadeIn		public function fadeIn() {			Mouse.show();			visible = true;			TweenLite.to(this, .5, {alpha:1, ease:Cubic.easeOut});		}		public function fadeOut(isComplete) {			TweenLite.to(this, .5, {alpha:0, ease:Cubic.easeIn, onComplete:fadeOutHandler});						function fadeOutHandler() {				visible = false;				if(isComplete != true && main.started == true){					Mouse.hide();				}			}		}			}}